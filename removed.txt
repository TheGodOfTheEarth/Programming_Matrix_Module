main.cpp: {

	 // Double
	 test = mat.Double();
	 cout << "\n\n" << "=== Doubled Matrix ===" << endl;
    test.Print();
}


Matrix.cpp: {

	// Создание копии матрицы
	Matrix Matrix::Double() const {
		Matrix result(nMatrR, nMatrC);
		Copy(this, &result);
		return result;
	}


	Matrix Matrix::Double() const {
		// Создаем матрицу без использования конструктора с параметрами
		Matrix result;
		
		// Создаем память вручную
		if (result.Create(nMatrR, nMatrC) != 0) {
			// Возвращаем пустую матрицу в случае ошибки
			return Matrix(); 
		}
		
		// Копируем данные вручную (без использования Copy())
		for (int r = 0; r < nMatrR; r++) {
			for (int c = 0; c < nMatrC; c++) {
					result.matr[r][c] = matr[r][c];
			}
		}
		
		result.sTitle = sTitle + " (копия)";
		result.bFull = bFull;
		
		return result;
	}




	// удаление пространства !!! не работает !!!
	Matrix::Errors Matrix::DeleteDim(TypeSide side, int index) {
		if (index < 0) return Errors::invalid_size;

		switch (side) {
			case TypeSide::Row:
					if (index >= nMatrR) return Errors::invalid_argument;

					for (int r = index; r < nMatrR - 1; r++) {
						for (int c = 0; c < nMatrC; c++) {
							matr[r][c] = matr[r + 1][c];
						}
					}

					if (Create(nMatrR - 1, nMatrC) != Errors::success)
						return Errors::bad_create;
					break;

			case TypeSide::Col:
					if (index >= nMatrC) return Errors::invalid_argument;

					for (int r = 0; r < nMatrR; r++) {
						for (int c = index; c < nMatrC - 1; c++) {
							matr[r][c] = matr[r][c + 1];
						}
					}

					if (Create(nMatrR, nMatrC - 1) != Errors::success)
						return Errors::bad_create;
					break;

			default:
					return Errors::invalid_typeside;
		}

		return Errors::success;
	}
}


Matrix.h: {
	    Matrix Double() const;
		 Matrix::Errors DeleteDim(TypeSide side, int index = -1);
}